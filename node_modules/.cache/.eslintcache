[{"/home/mwiemers/dev/Hangman/src/index.tsx":"1","/home/mwiemers/dev/Hangman/src/App.tsx":"2","/home/mwiemers/dev/Hangman/src/helpers/validespecialletters.ts":"3","/home/mwiemers/dev/Hangman/src/helpers/keyboardkeys.tsx":"4","/home/mwiemers/dev/Hangman/src/helpers/getRandomWord.tsx":"5","/home/mwiemers/dev/Hangman/src/components/Key.tsx":"6","/home/mwiemers/dev/Hangman/src/components/HangMan.tsx":"7","/home/mwiemers/dev/Hangman/src/components/WordLine.tsx":"8","/home/mwiemers/dev/Hangman/src/components/line.tsx":"9","/home/mwiemers/dev/Hangman/src/components/Head.tsx":"10","/home/mwiemers/dev/Hangman/src/words/wordlist.ts":"11"},{"size":281,"mtime":1659374263601,"results":"12","hashOfConfig":"13"},{"size":3860,"mtime":1659300356453,"results":"14","hashOfConfig":"13"},{"size":214,"mtime":1659296773543,"results":"15","hashOfConfig":"13"},{"size":897,"mtime":1659296773543,"results":"16","hashOfConfig":"13"},{"size":235,"mtime":1659300401533,"results":"17","hashOfConfig":"13"},{"size":630,"mtime":1659299258723,"results":"18","hashOfConfig":"13"},{"size":2155,"mtime":1659300272883,"results":"19","hashOfConfig":"13"},{"size":1134,"mtime":1659299382203,"results":"20","hashOfConfig":"13"},{"size":601,"mtime":1659298142783,"results":"21","hashOfConfig":"13"},{"size":1460,"mtime":1659299489653,"results":"22","hashOfConfig":"13"},{"size":167,"mtime":1659296773543,"results":"23","hashOfConfig":"13"},{"filePath":"24","messages":"25","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1thh039",{"filePath":"26","messages":"27","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"28"},{"filePath":"29","messages":"30","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"31","messages":"32","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"33","messages":"34","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"35"},{"filePath":"36","messages":"37","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"38"},{"filePath":"39","messages":"40","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41"},{"filePath":"42","messages":"43","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"44"},{"filePath":"45","messages":"46","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47"},{"filePath":"48","messages":"49","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50"},{"filePath":"51","messages":"52","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/home/mwiemers/dev/Hangman/src/index.tsx",[],"/home/mwiemers/dev/Hangman/src/App.tsx",["53"],"import './styles.css';\nimport styled from 'styled-components';\nimport { useCallback, useEffect, useState } from 'react';\nimport Hangman from './components/HangMan';\nimport Key from './components/Key';\nimport WordLine from './components/WordLine';\nimport KeyBoardKeys from './helpers/keyboardkeys';\nimport ValidateSpecialLetters from './helpers/validespecialletters';\nimport getRandomWord from './helpers/getRandomWord';\n\nconst KeyboardLine = styled.div``;\n\nconst Message = styled.div`\n  position: absolute;\n  display: flex;\n  flex-direction: column;\n  background-color: gray;\n  height: 100vh;\n  width: 90%;\n  font-size: 40px;\n  font-weight: bold;\n  align-items: center;\n  justify-content: center;\n`;\n\nconst ResetButton = styled.button`\n  border: none;\n  background-color: black;\n  color: white;\n  font-size: 1.5rem;\n  border-radius: 10px;\n  padding: 0.5rem 1rem;\n`;\n\nexport default function App() {\n  const [value, setValue] = useState<string>('');\n  const [trys, setTrys] = useState<number>(10);\n  const [finalWord, setFinalWord] = useState<string[]>([]);\n  const [message, setMessage] = useState<string>('');\n  const [gameOver, setGameOver] = useState<boolean>(false);\n  const [word, setWord] = useState<string>();\n  const [wordAsArray, setWordAsArray] = useState<string[]>([]);\n\n  const words = () => {\n    const newWord = getRandomWord().toUpperCase();\n    setWord(newWord);\n\n    const newArray = Object.assign([], word);\n    setWordAsArray(newArray);\n  };\n\n  useEffect(() => {\n    words();\n  }, [word]);\n\n  const handleKeyClick = (key: string) => {\n    console.log(word);\n    if (!word?.includes(key)) {\n      setTrys(trys - 1);\n    }\n    setValue(key);\n  };\n\n  const handleKeyDown = useCallback(\n    (event) => {\n      const key = event.key;\n\n      if (finalWord.includes(key.toUpperCase())) {\n        return;\n      }\n      if (!word?.includes(key.toUpperCase())) {\n        setTrys(trys - 1);\n      }\n      if (\n        (key.match('[A-Za-z]') && event.code.includes('Key')) ||\n        ValidateSpecialLetters(key)\n      ) {\n        setValue(key.toUpperCase());\n      } else {\n        setValue('');\n      }\n    },\n    [trys, finalWord, word]\n  );\n\n  const reset = () => {\n    setTrys(10);\n    words();\n    setMessage('');\n    setFinalWord([]);\n    setValue('');\n    setGameOver(false);\n  };\n\n  useEffect(() => {\n    if (wordAsArray.length === 0) {\n      return;\n    }\n    if (wordAsArray.every((l) => finalWord.includes(l))) {\n      setMessage('Du hast gewonnen!');\n    }\n  }, [finalWord, wordAsArray]);\n\n  useEffect(() => {\n    if (trys === 0) {\n      setGameOver(true);\n      setMessage('Du hast verloren');\n    }\n  }, [trys]);\n\n  useEffect(() => {\n    setFinalWord((oldArr) => [value, ...oldArr]);\n  }, [value]);\n\n  useEffect(() => {\n    if (window) {\n      window.addEventListener('keydown', handleKeyDown);\n    }\n\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n    };\n  }, [handleKeyDown]);\n\n  const KeyBoardLine = (number: number) =>\n    KeyBoardKeys.map(\n      (value) =>\n        number === value.line && (\n          <Key\n            disabled={finalWord.includes(value.value)}\n            onClick={() => handleKeyClick(value.value)}\n            value={value.value}\n          />\n        )\n    );\n\n  return (\n    <div className=\"App\">\n      {message && (\n        <Message>\n          {message}\n          <ResetButton onClick={reset}>Noch mal</ResetButton>\n        </Message>\n      )}\n      <h1>Hangman</h1>\n      <div style={{ height: 'min-content' }}>\n        <Hangman visibleIndex={trys} dead={gameOver} />\n      </div>\n      <KeyboardLine>{KeyBoardLine(1)}</KeyboardLine>\n      <KeyboardLine>{KeyBoardLine(2)}</KeyboardLine>\n      <KeyboardLine>{KeyBoardLine(3)}</KeyboardLine>\n\n      <WordLine winWord={word ? word : 'Kompromiss'} finalWord={finalWord} />\n      <p>Du hast noch {trys} Versuche</p>\n    </div>\n  );\n}\n","/home/mwiemers/dev/Hangman/src/helpers/validespecialletters.ts",[],"/home/mwiemers/dev/Hangman/src/helpers/keyboardkeys.tsx",[],"/home/mwiemers/dev/Hangman/src/helpers/getRandomWord.tsx",["54"],"import wordlist from '../words/wordlist';\n\nconst getRandomWord = () => {\n  const randomNumber = Math.floor(Math.random() * wordlist.length);\n  const newWord = wordlist[randomNumber];\n  return newWord;\n};\n\nexport default getRandomWord;\n","/home/mwiemers/dev/Hangman/src/components/Key.tsx",["55"],"import styled from 'styled-components';\n\ntype Props = {\n  value: string;\n  onClick(): void;\n  disabled: boolean;\n};\n\nconst StyledKey = styled.button`\n  border: black solid 1px;\n  width: 40px;\n  border-bottom: red solid 2px;\n  background-color: ${({ disabled }: Partial<Props>) =>\n    disabled ? 'white' : 'black'};\n  font-size: 24px;\n  font-weight: bold;\n  color: ${({ disabled }: Partial<Props>) => (disabled ? 'red' : 'white')};\n  margin: 2px;\n`;\n\nconst Key = ({ value, onClick, disabled }: Props) => {\n  return (\n    <StyledKey disabled={disabled} onClick={onClick}>\n      {value}\n    </StyledKey>\n  );\n};\n\nexport default Key;\n","/home/mwiemers/dev/Hangman/src/components/HangMan.tsx",["56"],"import styled from 'styled-components';\nimport Line, { StyledLine } from './line';\nimport Head from './Head';\n\ntype Props = {\n  visibleIndex: number;\n  dead: boolean;\n};\n\ntype StyleTypes = {\n  right?: boolean;\n};\n\nconst OverWrapper = styled.div`\n  height: 250px;\n`;\n\nconst Wrapper = styled.div`\n  position: relative;\n  left: 50%;\n  transform: translate(-50%);\n  width: max-content;\n`;\n\nconst Body = styled.div`\n  position: absolute;\n  left: 50%;\n  transform: translate(-50%);\n`;\n\nconst Arm = styled(StyledLine)`\n  position: absolute;\n  left: ${({ right }: StyleTypes) => (right ? '55px' : '18px')};\n  top: 70px;\n`;\n\nconst Leg = styled(StyledLine)`\n  position: absolute;\n  left: ${({ right }: StyleTypes) => (right ? '55px' : '18px')};\n  top: 135px;\n`;\n\nconst Cable = styled(StyledLine)`\n  position: absolute;\n  top: -30%;\n  left: -20px;\n`;\n\nconst LongStand = styled(StyledLine)`\n  position: absolute;\n  top: 35%;\n  left: -70px;\n`;\n\nconst StandLeg = styled(StyledLine)`\n  position: absolute;\n  left: ${({ right }: StyleTypes) => (right ? '-52px' : '-88px')};\n  top: 168px;\n`;\n\nconst Hangman = ({ visibleIndex, dead }: Props) => {\n  return (\n    <OverWrapper>\n      <Wrapper>\n        <StandLeg visible={visibleIndex < 10} height={50} rotate={45} />\n        <StandLeg\n          right={visibleIndex < 9}\n          visible={visibleIndex < 9}\n          height={50}\n          rotate={-45}\n        />\n        <LongStand visible={visibleIndex < 8} height={150} />\n        <Cable visible={visibleIndex < 7} height={100} rotate={90} />\n        <Head dead={dead} visible={visibleIndex < 6} />\n        <Body>\n          <Line visible={visibleIndex < 5} height={70} />\n        </Body>\n        <Arm visible={visibleIndex < 4} height={50} rotate={45} />\n        <Arm\n          right={visibleIndex < 3}\n          visible={visibleIndex < 3}\n          height={50}\n          rotate={-45}\n        />\n        <Leg visible={visibleIndex < 2} height={50} rotate={45} />\n        <Leg\n          right={visibleIndex < 1}\n          visible={visibleIndex < 1}\n          height={50}\n          rotate={-45}\n        />\n      </Wrapper>\n    </OverWrapper>\n  );\n};\n\nexport default Hangman;\n","/home/mwiemers/dev/Hangman/src/components/WordLine.tsx",["57"],"import { useEffect, useState } from 'react';\nimport styled from 'styled-components';\n\ntype Props = {\n  winWord: string;\n  finalWord: string[];\n};\n\ntype StyleProps = {\n  visible: boolean;\n};\n\nconst StyledLetter = styled.p`\n  font-size: 40px;\n  width: 40px;\n  margin-bottom: 5px;\n  margin-top: 0;\n  color: ${({ visible }: StyleProps) => (visible ? 'black' : 'transparent')};\n  border-bottom: black solid 2px;\n\n  ::selection {\n    background: transparent;\n    visibility: hidden;\n  }\n`;\n\nconst StyledLine = styled.div`\n  display: flex;\n  width: 100%;\n  justify-content: center;\n  align-items: flex-end;\n  column-gap: 10px;\n  height: 60px;\n`;\n\nconst WordLine = ({ winWord, finalWord }: Props) => {\n  const [word, setWord] = useState<string[]>([]);\n\n  useEffect(() => {\n    const wordArray = Object.assign([], winWord);\n    setWord(wordArray);\n  }, [winWord]);\n\n  const letters = word.map((letter, index) => (\n    <StyledLetter\n      key={index}\n      visible={finalWord.includes(letter.toUpperCase())}\n    >\n      {letter.toUpperCase()}\n    </StyledLetter>\n  ));\n\n  return <StyledLine>{letters}</StyledLine>;\n};\n\nexport default WordLine;\n","/home/mwiemers/dev/Hangman/src/components/line.tsx",["58"],"import styled from \"styled-components\";\n\ntype Props = {\n  height: number;\n  visible?: boolean;\n  rotate?: number;\n};\n\nexport const StyledLine = styled.div`\n  background-color: black;\n  width: 3px;\n  height: ${({ height }: Props) => height && `${height}px`};\n  visibility: ${({ visible }: Props) => (visible ? \"inherit\" : \"hidden\")};\n  transform: rotate(\n    ${({ rotate }: Props) => (rotate ? `${rotate}deg` : \"rotate(0deg)\")}\n  );\n`;\n\nconst Line = ({ height, visible, rotate }: Props) => {\n  return <StyledLine height={height} visible={visible} rotate={rotate}></StyledLine>\n};\n\nexport default Line;\n","/home/mwiemers/dev/Hangman/src/components/Head.tsx",["59"],"import styled from 'styled-components';\n\ntype Props = {\n  visible: boolean;\n  dead: boolean;\n};\n\ntype FaceProps = {\n  right: boolean;\n};\n\nconst Wrapper = styled.div`\n  visibility: ${({ visible }: Partial<Props>) =>\n    visible ? 'inherit' : 'hidden'};\n`;\n\nconst StyledCircle = styled.div`\n  position: relative;\n  height: 75px;\n  width: 75px;\n  background-color: black;\n  border-radius: 50%;\n`;\n\nconst StyledFace = styled.div`\n  position: absolute;\n  left: 2px;\n  top: 2px;\n  height: 70px;\n  width: 70px;\n  background-color: white;\n  border-radius: 50%;\n`;\n\nconst StyledEye = styled.div`\n  position: absolute;\n  left: ${({ right }: Partial<FaceProps>) => (right ? '50px' : '15px')};\n  top: 20px;\n  height: 5px;\n  width: 5px;\n  background-color: black;\n  border-radius: 50%;\n`;\n\nconst StyledMouth = styled.div`\n  position: absolute;\n  left: 20px;\n  top: 50px;\n  height: 5px;\n  width: 30px;\n  background-color: black;\n`;\n\nconst DeadEye = styled.p`\n  font-weight: bold;\n  position: absolute;\n  left: ${({ right }: Partial<FaceProps>) => (right ? '46px' : '13px')};\n  top: 20px;\n  margin: 0;\n`;\n\nconst Head = ({ visible, dead }: Props) => {\n  return (\n    <Wrapper visible={visible}>\n      <StyledCircle>\n        <StyledFace>\n          {dead ? <DeadEye>X</DeadEye> : <StyledEye />}\n          {dead ? <DeadEye right>X</DeadEye> : <StyledEye right />}\n          <StyledMouth />\n        </StyledFace>\n      </StyledCircle>\n    </Wrapper>\n  );\n};\n\nexport default Head;\n","/home/mwiemers/dev/Hangman/src/words/wordlist.ts",[],{"ruleId":"60","severity":1,"message":"61","line":35,"column":16,"nodeType":"62","messageId":"63","endLine":35,"endColumn":30},{"ruleId":"60","severity":1,"message":"61","line":3,"column":23,"nodeType":"64","messageId":"63","endLine":3,"endColumn":28},{"ruleId":"60","severity":1,"message":"61","line":21,"column":13,"nodeType":"64","messageId":"63","endLine":21,"endColumn":53},{"ruleId":"60","severity":1,"message":"61","line":61,"column":17,"nodeType":"64","messageId":"63","endLine":61,"endColumn":51},{"ruleId":"60","severity":1,"message":"61","line":36,"column":18,"nodeType":"64","messageId":"63","endLine":36,"endColumn":52},{"ruleId":"60","severity":1,"message":"61","line":19,"column":14,"nodeType":"64","messageId":"63","endLine":19,"endColumn":53},{"ruleId":"60","severity":1,"message":"61","line":62,"column":14,"nodeType":"64","messageId":"63","endLine":62,"endColumn":43},"@typescript-eslint/explicit-module-boundary-types","Missing return type on function.","FunctionDeclaration","missingReturnType","ArrowFunctionExpression"]